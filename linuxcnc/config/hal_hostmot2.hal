# Interface to hardware using Mesa Electronics 6i25 control card.

#loadrt hostmot2 debug_idrom=1 debug_module_descriptors=1 debug_pin_descriptors=1 debug_modules=1
loadrt hostmot2
loadrt [HOSTMOT2](DRIVER) config=[HOSTMOT2](CONFIG)

# Read inputs at start of servo loop and write outputs at end
addf hm2_[HOSTMOT2](BOARD).0.read          servo-thread    1
addf mux2.1 servo-thread
addf scale.1 servo-thread
addf hm2_[HOSTMOT2](BOARD).0.write         servo-thread   -1

# Global PWM frequency
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.pwm_frequency 40000

# Watchdog timeout 10ms
setp hm2_[HOSTMOT2](BOARD).0.watchdog.timeout_ns 10000000

#################
# Power control #
#################

# GPIO 16: MOTOR_HCURR, enable higher forces when in automatic mode.
setp hm2_[HOSTMOT2](BOARD).0.gpio.016.is_output 1
net powerctl.mso1_latched => hm2_[HOSTMOT2](BOARD).0.gpio.016.out

# GPIO 18: PWR_ENABLE (high = connect +48V to motors)
# Normally this is enabled as soon as LinuxCNC is active.
# Hardware mode switch controls 230 VAC supply to the +48 V power supply.
# When estop is pressed, this switch is used to cut power fast.
setp hm2_[HOSTMOT2](BOARD).0.gpio.018.is_output 1
net powerctl.estop_off => hm2_[HOSTMOT2](BOARD).0.gpio.018.out

# GPIO 20: POWER_GOOD (pullup, low state = +48V supply ok)
# Inverted because powerctl.power_good is active high
net powerctl.power_good <= hm2_[HOSTMOT2](BOARD).0.gpio.020.in_not

# GPIO 22: ESTOP_INFO (pullup, high state = estop pressed)
net powerctl.estop_btn <= hm2_[HOSTMOT2](BOARD).0.gpio.022.in

# GPIO 24: MSO1_ACTIVE (pullup, low state = MSO1 is active and door closed)
# Inverted because powerctl.mso1_switch is active high
net powerctl.mso1_switch <= hm2_[HOSTMOT2](BOARD).0.gpio.024.in_not

# GPIO 31: Run button (pullup, low state = button pressed)
net powerctl.pause_btn <= hm2_[HOSTMOT2](BOARD).0.gpio.031.in_not

# GPIO 32: Run button (pullup, low state = button pressed)
net powerctl.run_btn <= hm2_[HOSTMOT2](BOARD).0.gpio.032.in_not

# GPIO 33: Run / pause indicator LEDs (low = run, high = pause)
setp hm2_[HOSTMOT2](BOARD).0.gpio.033.is_output 1
net powerctl.pause_indicator =>  hm2_[HOSTMOT2](BOARD).0.gpio.033.out

# GPIO 1: Motor fault signal (active low)
net powerctl.motor_ok <= hm2_[HOSTMOT2](BOARD).0.gpio.001.in

# GPIO 27: Probe sensor
net powerctl.probe_sensor <= hm2_[HOSTMOT2](BOARD).0.gpio.027.out

########################
# X-axis encoder input #
########################
setp hm2_[HOSTMOT2](BOARD).0.encoder.00.counter-mode 0
setp hm2_[HOSTMOT2](BOARD).0.encoder.00.filter 1
setp hm2_[HOSTMOT2](BOARD).0.encoder.00.scale  [ENCODERS]STEP_PER_MM_X
net motordrive.0.feedback <= hm2_[HOSTMOT2](BOARD).0.encoder.00.position
net motordrive.0.feedback_deriv pid.0.feedback-deriv <= hm2_[HOSTMOT2](BOARD).0.encoder.00.velocity

########################
# Y-axis encoder input #
########################
setp hm2_[HOSTMOT2](BOARD).0.encoder.01.counter-mode 0
setp hm2_[HOSTMOT2](BOARD).0.encoder.01.filter 1
setp hm2_[HOSTMOT2](BOARD).0.encoder.01.scale  [ENCODERS]STEP_PER_MM_Y
net motordrive.1.feedback <= hm2_[HOSTMOT2](BOARD).0.encoder.01.position
net motordrive.1.feedback_deriv pid.1.feedback-deriv <= hm2_[HOSTMOT2](BOARD).0.encoder.01.velocity

########################
# Z-axis encoder input #
########################
setp hm2_[HOSTMOT2](BOARD).0.encoder.02.counter-mode 0
setp hm2_[HOSTMOT2](BOARD).0.encoder.02.filter 1
setp hm2_[HOSTMOT2](BOARD).0.encoder.02.scale  [ENCODERS]STEP_PER_MM_Z
net motordrive.2.feedback <= hm2_[HOSTMOT2](BOARD).0.encoder.02.position
net motordrive.2.feedback_deriv pid.2.feedback-deriv <= hm2_[HOSTMOT2](BOARD).0.encoder.02.velocity

###################
# Homing switches #
###################
net motordrive.0.home_sw joint.0.home-sw-in <= hm2_[HOSTMOT2](BOARD).0.gpio.003.in
net motordrive.1.home_sw joint.1.home-sw-in <= hm2_[HOSTMOT2](BOARD).0.gpio.005.in
net motordrive.2.home_sw joint.2.home-sw-in <= hm2_[HOSTMOT2](BOARD).0.gpio.007.in

#####################
# X-axis PWM output #
#####################
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.00.output-type 2
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.00.scale [MOTORDRIVE]SUPPLY_VOLTAGE
net motordrive.0.control => hm2_[HOSTMOT2](BOARD).0.pwmgen.00.value
net motordrive.0.enable => hm2_[HOSTMOT2](BOARD).0.pwmgen.00.enable

#####################
# Y-axis PWM output #
#####################
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.01.output-type 2
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.01.scale [MOTORDRIVE]SUPPLY_VOLTAGE
net motordrive.1.control => hm2_[HOSTMOT2](BOARD).0.pwmgen.01.value
net motordrive.1.enable => hm2_[HOSTMOT2](BOARD).0.pwmgen.01.enable

#####################
# Z-axis PWM output #
#####################
# Old: PWM output for 5A motor driver
# setp hm2_[HOSTMOT2](BOARD).0.pwmgen.02.output-type 2
# setp hm2_[HOSTMOT2](BOARD).0.pwmgen.02.scale -[MOTORDRIVE]SUPPLY_VOLTAGE
# net motordrive.2.control => hm2_[HOSTMOT2](BOARD).0.pwmgen.02.value
# net motordrive.2.enable => hm2_[HOSTMOT2](BOARD).0.pwmgen.02.enable

# RC PWM output for FSESC 4.20
setp hm2_[HOSTMOT2](BOARD).0.rcpwmgen.rate 1000
setp scale.1.gain -0.006
setp scale.1.offset 0.5
net motordrive.2.control => scale.1.in
net motordrive.2.scaled scale.1.out => mux2.1.in1
setp mux2.1.in0 0
net motordrive.2.enable => mux2.1.sel
net motordrive.2.pwmwidth mux2.1.out => hm2_[HOSTMOT2](BOARD).0.rcpwmgen.00.width

########################
# Spindle PWM control  #
########################
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.03.output-type 1
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.03.scale [SPINDLE]MAX_RPM
net powerctl.spindle_rpm => hm2_[HOSTMOT2](BOARD).0.pwmgen.03.value
net powerctl.spindle_enable => hm2_[HOSTMOT2](BOARD).0.pwmgen.03.enable
net powerctl.spindle_at_speed <= hm2_[HOSTMOT2](BOARD).0.gpio.028.in
