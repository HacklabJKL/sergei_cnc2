# Interface to hardware using Mesa Electronics 6i25 control card.

#loadrt hostmot2 debug_idrom=1 debug_module_descriptors=1 debug_pin_descriptors=1 debug_modules=1
loadrt hostmot2
loadrt [HOSTMOT2](DRIVER) config=[HOSTMOT2](CONFIG)

loadrt debounce cfg=5

# Read inputs at start of servo loop and write outputs at end
addf hm2_[HOSTMOT2](BOARD).0.read          servo-thread    1
addf debounce.0 servo-thread 2
addf mux2.1 servo-thread
addf scale.1 servo-thread
addf hm2_[HOSTMOT2](BOARD).0.write         servo-thread   -1

# Global PWM frequency
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.pwm_frequency 22000

# PDM generator is used for slower FETs
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.pdm_frequency 5000

# Watchdog timeout 10ms
setp hm2_[HOSTMOT2](BOARD).0.watchdog.timeout_ns 10000000

#################
# Power control #
#################

# 10 ms filtering for button inputs
setp debounce.0.delay 10

# GPIO 16: MOTOR_HCURR, enable higher forces when in automatic mode.
setp hm2_[HOSTMOT2](BOARD).0.gpio.016.is_output 1
net powerctl.allow_auto => hm2_[HOSTMOT2](BOARD).0.gpio.016.out

# GPIO 18: PWR_ENABLE (high = connect +48V to motors)
# Normally this is enabled as soon as LinuxCNC is active.
# Hardware mode switch controls 230 VAC supply to the +48 V power supply.
# When estop is pressed, this switch is used to cut power fast.
setp hm2_[HOSTMOT2](BOARD).0.gpio.018.is_output 1
net powerctl.power_enable => hm2_[HOSTMOT2](BOARD).0.gpio.018.out

# GPIO 20: POWER_GOOD (pullup, low state = +48V supply ok)
# Inverted because powerctl.power_good is active high
net powerctl.power_good_raw <= hm2_[HOSTMOT2](BOARD).0.gpio.020.in_not
net powerctl.power_good_raw => debounce.0.0.in
net powerctl.power_good <= debounce.0.0.out

# GPIO 22: ESTOP_INFO (pullup, high state = estop pressed)
net powerctl.estop_btn_raw <= hm2_[HOSTMOT2](BOARD).0.gpio.022.in
net powerctl.estop_btn_raw => debounce.0.1.in
net powerctl.estop_btn <= debounce.0.1.out

# GPIO 24: MSO1_ACTIVE (pullup, low state = MSO1 is active and door closed)
# Inverted because powerctl.mso1_switch is active high
net powerctl.mso1_switch_raw <= hm2_[HOSTMOT2](BOARD).0.gpio.024.in_not
net powerctl.mso1_switch_raw => debounce.0.2.in
net powerctl.mso1_switch <= debounce.0.2.out

# GPIO 31: Pause button (pullup, low state = button pressed)
net powerctl.pause_btn_raw <= hm2_[HOSTMOT2](BOARD).0.gpio.031.in_not
net powerctl.pause_btn_raw => debounce.0.3.in
net powerctl.pause_btn <= debounce.0.3.out

# GPIO 32: Run button (pullup, low state = button pressed)
net powerctl.run_btn_raw <= hm2_[HOSTMOT2](BOARD).0.gpio.032.in_not
net powerctl.run_btn_raw => debounce.0.4.in
net powerctl.run_btn <= debounce.0.4.out

# GPIO 33: Run / pause indicator LEDs (low = run, high = pause)
setp hm2_[HOSTMOT2](BOARD).0.gpio.033.is_output 1
net powerctl.pause_indicator =>  hm2_[HOSTMOT2](BOARD).0.gpio.033.out

# GPIO 1: Motor fault signal (active low)
net powerctl.motor_ok <= hm2_[HOSTMOT2](BOARD).0.gpio.001.in

# GPIO 27: Probe sensor
net powerctl.probe_sensor <= hm2_[HOSTMOT2](BOARD).0.gpio.027.in_not

########################
# X-axis encoder input #
########################
setp hm2_[HOSTMOT2](BOARD).0.encoder.00.counter-mode 0
setp hm2_[HOSTMOT2](BOARD).0.encoder.00.filter 1
setp hm2_[HOSTMOT2](BOARD).0.encoder.00.scale  [ENCODERS]STEP_PER_MM_X
net motordrive.0.feedback <= hm2_[HOSTMOT2](BOARD).0.encoder.00.position
net motordrive.0.feedback_deriv pid.0.feedback-deriv <= hm2_[HOSTMOT2](BOARD).0.encoder.00.velocity

########################
# Y-axis encoder input #
########################
setp hm2_[HOSTMOT2](BOARD).0.encoder.01.counter-mode 0
setp hm2_[HOSTMOT2](BOARD).0.encoder.01.filter 1
setp hm2_[HOSTMOT2](BOARD).0.encoder.01.scale  [ENCODERS]STEP_PER_MM_Y
net motordrive.1.feedback <= hm2_[HOSTMOT2](BOARD).0.encoder.01.position
net motordrive.1.feedback_deriv pid.1.feedback-deriv <= hm2_[HOSTMOT2](BOARD).0.encoder.01.velocity

########################
# Z-axis encoder input #
########################
setp hm2_[HOSTMOT2](BOARD).0.encoder.02.counter-mode 0
setp hm2_[HOSTMOT2](BOARD).0.encoder.02.filter 1
setp hm2_[HOSTMOT2](BOARD).0.encoder.02.scale  [ENCODERS]STEP_PER_MM_Z
net motordrive.2.feedback <= hm2_[HOSTMOT2](BOARD).0.encoder.02.position
net motordrive.2.feedback_deriv pid.2.feedback-deriv <= hm2_[HOSTMOT2](BOARD).0.encoder.02.velocity

###################
# Homing switches #
###################
net motordrive.0.home_sw joint.0.home-sw-in <= hm2_[HOSTMOT2](BOARD).0.gpio.003.in
net motordrive.1.home_sw joint.1.home-sw-in <= hm2_[HOSTMOT2](BOARD).0.gpio.005.in
net motordrive.2.home_sw joint.2.home-sw-in <= hm2_[HOSTMOT2](BOARD).0.gpio.007.in

#####################
# X-axis PWM output #
#####################
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.00.output-type 2
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.00.scale [MOTORDRIVE]SUPPLY_VOLTAGE
net motordrive.0.control => hm2_[HOSTMOT2](BOARD).0.pwmgen.00.value
net motordrive.0.enable => hm2_[HOSTMOT2](BOARD).0.pwmgen.00.enable

#####################
# Y-axis PWM output #
#####################
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.01.output-type 2
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.01.scale [MOTORDRIVE]SUPPLY_VOLTAGE
net motordrive.1.control => hm2_[HOSTMOT2](BOARD).0.pwmgen.01.value
net motordrive.1.enable => hm2_[HOSTMOT2](BOARD).0.pwmgen.01.enable

#####################
# Z-axis PWM output #
#####################
# Old: PWM output for 5A motor driver
# setp hm2_[HOSTMOT2](BOARD).0.pwmgen.02.output-type 2
# setp hm2_[HOSTMOT2](BOARD).0.pwmgen.02.scale -[MOTORDRIVE]SUPPLY_VOLTAGE
# net motordrive.2.control => hm2_[HOSTMOT2](BOARD).0.pwmgen.02.value
# net motordrive.2.enable => hm2_[HOSTMOT2](BOARD).0.pwmgen.02.enable

# Old: RC PWM output for FSESC 4.20 servo port input
#setp hm2_[HOSTMOT2](BOARD).0.rcpwmgen.rate 1000
#setp scale.1.gain -0.006
#setp scale.1.offset 0.5
#net motordrive.2.control => scale.1.in
#net motordrive.2.scaled scale.1.out => mux2.1.in1
#setp mux2.1.in0 0
#net motordrive.2.enable => mux2.1.sel
#net motordrive.2.pwmwidth mux2.1.out => hm2_[HOSTMOT2](BOARD).0.rcpwmgen.00.width

# PWM & DIR output for BLDC servo amplifier
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.02.output-type 1
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.02.scale [MOTORDRIVE]SUPPLY_VOLTAGE
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.02.out0.invert_output 1
net motordrive.2.control => hm2_[HOSTMOT2](BOARD).0.pwmgen.02.value
net motordrive.2.enable => hm2_[HOSTMOT2](BOARD).0.pwmgen.02.enable

########################
# Spindle PWM control  #
########################
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.03.output-type 1
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.03.scale 20000
net powerctl.spindle_rpm => hm2_[HOSTMOT2](BOARD).0.pwmgen.03.value
net powerctl.spindle_enable => hm2_[HOSTMOT2](BOARD).0.pwmgen.03.enable
net powerctl.spindle_at_speed <= hm2_[HOSTMOT2](BOARD).0.gpio.028.in

########################
# Coolant PDM control  #
########################
# Motor is 6V motor => scale is set to 200 to limit max duty to 50%
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.04.output-type 3
setp hm2_[HOSTMOT2](BOARD).0.pwmgen.04.scale 200
net powerctl.coolant_rate => hm2_[HOSTMOT2](BOARD).0.pwmgen.04.value
net powerctl.coolant_enabled => hm2_[HOSTMOT2](BOARD).0.pwmgen.04.enable

# Air valve control
setp hm2_[HOSTMOT2](BOARD).0.gpio.023.is_output 1
net powerctl.coolant_air =>  hm2_[HOSTMOT2](BOARD).0.gpio.023.out


