# Power-on and emergency stop control.

# Note: some components loaded here are used from other files.
loadrt not count=2
loadrt lut5 count=17
loadrt timedelay count=5
loadrt mux2 count=4
loadrt near count=1
loadrt scale count=2
loadrt absmaxdecay count=1
loadrt abslimit count=1
loadrt sum2 count=4

addf abslimit.0   servo-thread
addf absmaxdecay.0 servo-thread
addf scale.0    servo-thread
addf not.0      servo-thread
addf not.1      servo-thread
addf lut5.0     servo-thread
addf lut5.1     servo-thread
addf lut5.2     servo-thread
addf lut5.3     servo-thread
addf lut5.4     servo-thread
addf lut5.5     servo-thread
addf lut5.6     servo-thread
addf lut5.7     servo-thread
addf lut5.8     servo-thread
addf lut5.9     servo-thread
addf lut5.10    servo-thread
addf lut5.11    servo-thread
addf lut5.13    servo-thread
addf lut5.15    servo-thread
addf timedelay.0 servo-thread
addf timedelay.1 servo-thread
addf timedelay.2 servo-thread
addf timedelay.3 servo-thread
addf timedelay.4 servo-thread
addf mux2.0     servo-thread
addf mux2.2     servo-thread
addf near.0     servo-thread
addf lut5.12    servo-thread
addf lut5.14    servo-thread

# Signals to hardware / simulator panel
newsig powerctl.mso1_switch bit
newsig powerctl.allow_auto bit
newsig powerctl.estop_btn bit
newsig powerctl.estop_off bit
newsig powerctl.run_btn bit
newsig powerctl.pause_btn bit
newsig powerctl.power_good bit
newsig powerctl.program_paused bit
newsig powerctl.program_running bit
newsig powerctl.machine_homed bit
newsig powerctl.machine_is_on bit
newsig powerctl.start_homing_btn bit
newsig powerctl.pause_indicator bit
newsig powerctl.spindle_enable bit
newsig powerctl.spindle_at_speed bit
newsig powerctl.spindle_rpm float
newsig powerctl.velocity_mm_s float
newsig powerctl.velocity_mm_min float
newsig powerctl.ferror float
newsig powerctl.motor_ok bit
newsig powerctl.probe_sensor bit
newsig powerctl.paused_door_open bit
newsig powerctl.lift_z bit

net powerctl.program_paused <= halui.program.is-paused
net powerctl.program_running <= halui.program.is-running

net tool-prep-loop iocontrol.0.tool-prepare => iocontrol.0.tool-prepared
net tool-change-loop iocontrol.0.tool-change => iocontrol.0.tool-changed

#######################
# Run / pause buttons
# In automatic mode (MSO 1):
#  - Pressing RUN starts or resumes the program
#  - Pressing PAUSE pauses the program or acts as
#    emergency stop if program is not running.
#  - Opening door acts as pause
#  - Holding RUN overrides the door switch
#
# In setup mode (MSO 2):
#  - Automatic program start is not possible
#  - Pressing PAUSE acts as emergency stop
#  - Maximum speed 2000 mm/min (33 mm/s)
#  - Spindle cannot be started

# Actual emergency stop mechanism cuts power in hardware, but the software
# loop provides feedback for GUI and faster stopping.
# lut5.0: Combine estop signals (high = estop activated)
# out = !(in0 | in1 | in2 | in3 | in4)
setp lut5.0.function 0x01
net powerctl.estop_off lut5.0.out => iocontrol.0.emc-enable-in
net powerctl.estop_btn => lut5.0.in-0
net motordrive.fault => lut5.0.in-2

# lut5.1: If program is not running and door is closed, run button starts.
# out = in0 & in1 & in2 & in3 & in4
setp lut5.1.function 0x80000000
net powerctl.run_btn => lut5.1.in-0
net powerctl.program_idle halui.program.is-idle => lut5.1.in-1
net powerctl.machine_homed => lut5.1.in-2
net powerctl.power_good => lut5.1.in-3
net powerctl.mso1_switch => lut5.1.in-4
net powerctl.run lut5.1.out => halui.program.run

# lut5.2: If program is paused, run button resumes.
# out = in0 & in1 & in3
setp lut5.2.function 0x80
net powerctl.run_btn => lut5.2.in-0
net powerctl.program_paused halui.program.is-paused => lut5.2.in-1
net powerctl.allow_auto => lut5.2.in-2
net powerctl.resume lut5.2.out => halui.program.resume

# lut5.3: Pause with button, prevent running if not in MSO1 mode
# out = (in0 & in1) | (!in2 & in1)
setp lut5.3.function 0x8C
net powerctl.pause_btn => lut5.3.in-0
net powerctl.program_running => lut5.3.in-1
net powerctl.allow_auto => lut5.3.in-2
net powerctl.pause lut5.3.out => halui.program.pause

# lut5.14: Show notification if automatic movements are attempted with door open
# out = !(in0 & !in1)
setp lut5.14.function 0x0D
net powerctl.program_paused => lut5.14.in-0
net powerctl.allow_auto => lut5.14.in-1
net powerctl.paused_door_open <= lut5.14.out

# Jogging / homing cannot be paused, so if program is not
# running, pause button should act as estop.
# lut5.4: Set estop when program not running and pause pressed
# out = (in0 & in1)
setp lut5.4.function 0x08
net powerctl.pause_btn => lut5.4.in-0
net powerctl.program_idle halui.program.is-idle => lut5.4.in-1
net powerctl.estop_pause lut5.4.out => lut5.0.in-1

# Override MSO1 switch & door switch state when RUN button is held down.
# This allows ISO16090 MSO3 "manual intervention" to keep running
# with guards open. As soon as the RUN button is released the program
# will be paused.
# out = in0 | in1
setp timedelay.3.on-delay 0.5
setp timedelay.3.off-delay 0.01
setp lut5.5.function 0x06
net powerctl.run_btn => timedelay.3.in
net powerctl.run_btn_held timedelay.3.out => lut5.5.in-0
net powerctl.mso1_switch => lut5.5.in-1
net powerctl.allow_auto <= lut5.5.out

# Enable power in UI when power good signal is high
# The power-on must be delayed to give the GUI time to react when estop turns off.
# Additional delay is needed to wait for Z axis driver to boot
# lut5.6: out = !in0 | !in1
setp lut5.6.function 0x06
setp timedelay.0.on-delay 5.0
setp timedelay.0.off-delay 0.01
net powerctl.power_good => lut5.6.in-0
net powerctl.estop_off => lut5.6.in-1
net powerctl.machine_off lut5.6.out => halui.machine.off
net powerctl.machine_off => not.0.in
net powerctl.machine_on not.0.out => timedelay.0.in
net powerctl.machine_on_delayed timedelay.0.out => halui.machine.on
net powerctl.machine_is_on <= halui.machine.is-on

# Check machine homing status
# lut5.7: out = in0 & in1 & in2
setp lut5.7.function 0x80
net powerctl.homed_x joint.0.homed => lut5.7.in-0
net powerctl.homed_y joint.1.homed => lut5.7.in-1
net powerctl.homed_z joint.2.homed => lut5.7.in-2
net powerctl.machine_homed <= lut5.7.out

# Pause button indicator:
# If program running, use program state.
# Otherwise use motion.in-position.
# lut5.9: out = in1 | (!in0 & in2)
setp lut5.9.function 0xDC
net powerctl.program_running => lut5.9.in-0
net powerctl.program_paused => lut5.9.in-1
net powerctl.in_position motion.in-position => lut5.9.in-2
net powerctl.pause_indicator <= lut5.9.out

# Spindle RPM limit
setp abslimit.0.min [SPINDLE](MIN_RPM)
setp abslimit.0.max [SPINDLE](MAX_RPM)
net powerctl.spindle_rpm_req spindle.0.speed-out => abslimit.0.in
net powerctl.spindle_rpm <= abslimit.0.out

# Spindle control
# Stop when not in MSO1 mode or when estop hit
# lut5.10: out = in0 & in1 & in2
setp lut5.10.function 0x80
net powerctl.spindle_on spindle.0.on => lut5.10.in-0
net powerctl.allow_auto => lut5.10.in-1
net powerctl.estop_off => lut5.10.in-2
net powerctl.spindle_enable <= lut5.10.out

# Noise filtering for spindle at speed signal
setp timedelay.2.on-delay 0.1
setp timedelay.2.off-delay 0.1
net powerctl.spindle_at_speed => timedelay.2.in
net powerctl.spindle_at_speed_filtered timedelay.2.out => spindle.0.at-speed

# Feed hold
# Stop feeding until spindle is at speed.
# This is for resuming from pause / door open, and also in case spindle fails mid-move.
# Normally LinuxCNC only waits for spindle speed after speed change.
# lut5.11: out = in0 & !in1
setp lut5.11.function 0x02
net powerctl.spindle_on => lut5.11.in-0
net powerctl.spindle_at_speed_filtered => lut5.11.in-1
net powerctl.feed-inhibit motion.feed-inhibit <= lut5.11.out

# Spindle monitoring
# Detect when spindle speed is requested to change
# Throw error if spindle speedup takes more than 5 seconds
# spindle_rpm => mux => spindle_rpm_old => near => timedelay => lut => spindle_fault
# lut5.12: out = in0 & in1 & !in2
# lut5.13: out = in0 & in1
setp lut5.12.function 0x08
setp lut5.13.function 0x08
setp near.0.difference 10
setp timedelay.1.on-delay 5.0
setp timedelay.1.off-delay 0.0
net powerctl.spindle_rpm => mux2.0.in0
net powerctl.spindle_rpm_old mux2.0.out => mux2.0.in1
net powerctl.spindle_rpm => near.0.in1
net powerctl.spindle_rpm_old => near.0.in2
net powerctl.spindle_rpm_near_old near.0.out => lut5.13.in-0
net powerctl.spindle_enable => lut5.13.in-1
net powerctl.spindle_rpm_stable lut5.13.out => mux2.0.sel
net powerctl.spindle_rpm_stable => timedelay.1.in
net powerctl.spindle_rpm_stable_delayed timedelay.1.out => lut5.12.in-0
net powerctl.spindle_enable => lut5.12.in-1
net powerctl.spindle_at_speed_filtered => lut5.12.in-2
net powerctl.spindle_fault lut5.12.out => spindle.0.amp-fault-in

# Machine velocity monitoring
setp scale.0.gain 60
net powerctl.velocity_mm_s motion.current-vel => scale.0.in
net powerctl.velocity_mm_min <= scale.0.out

# Path following error
# Maximum of absolute values for all axes, and lowpassed to make it easier to read.
setp absmaxdecay.0.decay-time 200
net powerctl.ferror-x joint.0.f-error => absmaxdecay.0.in0
net powerctl.ferror-y joint.1.f-error => absmaxdecay.0.in1
net powerctl.ferror-z joint.2.f-error => absmaxdecay.0.in2
net powerctl.ferror <= absmaxdecay.0.out

# Probe sensor
# For 3d probe the signal levels are inverted.
# lut5.15: in0 xor in1
setp lut5.15.function 0x06
setp timedelay.4.on-delay 0.005
setp timedelay.4.off-delay 0.005
net powerctl.probe_polarity => lut5.15.in-0
net powerctl.probe_sensor => lut5.15.in-1
net powerctl.probe_xored lut5.15.out => timedelay.4.in
net powerctl.probe_filt timedelay.4.out => motion.probe-input

# Maximum velocity based on door status
# Limit to 2 m/s when door is open for ISO16090 conformance
setp mux2.2.in1 [AXIS_X]MAX_VELOCITY
setp mux2.2.in0 33.4
net powerctl.mso1_switch => mux2.2.sel
net powerctl.max_speed_xy <= mux2.2.out

# Disable homing until door closed
net powerctl.allow_auto => not.1.in
net powerctl.home_inhibit not.1.out => motion.homing-inhibit
